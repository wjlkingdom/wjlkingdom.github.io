<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title></title>
    <description>Natural Language Processing, Semantic Embedding, Machine learning, deep learning</description>    
    <link>http://yanran.li</link>
    <atom:link href="http://yanran.li/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>DeepWalk Online Learning of Social Representations</title>
                
        
          <description>&lt;p&gt;《&lt;strong&gt;DeepWalk: Online Learning of Social Representations&lt;/strong&gt;》是一篇我个人非常喜欢的论文，不仅提出了一个想法，更展示了这个想法的可行性和可能空间。提出的想法是利用网络结构信息将用户表示为低维实值向量，学出来的表示是最重要的，因为有了表示就可以用来加在许多其他任务上。&lt;/p&gt;

</description>
        
        <pubDate>Sat, 18 Apr 2015 00:00:00 +0800</pubDate>
        <link>http://yanran.li/peppypapers/2015/04/18/DeepWalk-Online-Learning-of-Social-Representations.html</link>
        <guid isPermaLink="true">http://yanran.li/peppypapers/2015/04/18/DeepWalk-Online-Learning-of-Social-Representations.html</guid>
      </item>
    
      <item>
        <title>Collections of Tips for Machine Learning</title>
                
        
          <description>&lt;p&gt;收集了一些我觉得真的有用实战机器学习的文章。比如如何调参，比如会遇到什么真实数据带来的问题，如何 debug，如何 speed-up。长期更新。&lt;/p&gt;

</description>
        
        <pubDate>Fri, 17 Apr 2015 00:00:00 +0800</pubDate>
        <link>http://yanran.li/machinelearning/2015/04/17/collections-of-tips-for-machine-learning.html</link>
        <guid isPermaLink="true">http://yanran.li/machinelearning/2015/04/17/collections-of-tips-for-machine-learning.html</guid>
      </item>
    
      <item>
        <title>我是这样进行知识管理的</title>
                
        
          <description>&lt;p&gt;写这篇博客是前几天看到别人分享 pluskid 的&lt;a href=&quot;http://freemind.pluskid.org/misc/knowledge-accumulate/&quot;&gt;《关于知识整理、积累与记忆》&lt;/a&gt;，加之我自己一直以来也很关注这件事，也有一点点心得。整理出来自己回顾，和大家讨论。&lt;/p&gt;

</description>
        
        <pubDate>Wed, 15 Apr 2015 00:00:00 +0800</pubDate>
        <link>http://yanran.li/life/2015/04/15/how-i-manage-my-knowledge.html</link>
        <guid isPermaLink="true">http://yanran.li/life/2015/04/15/how-i-manage-my-knowledge.html</guid>
      </item>
    
      <item>
        <title>Github Pages Categories with Jekyll</title>
                
        
          <description>&lt;p&gt;When Jekyll is friendly to tags in post, it is not that .&lt;/p&gt;

&lt;p&gt;There are three questions that you’ll encounter using categories: (1) Multiple word category name; (2) Multi categories; (3) Archive posts by a specific category.&lt;/p&gt;

&lt;h2 id=&quot;multiple-word-category-name&quot;&gt;Multiple word category name&lt;/h2&gt;

&lt;p&gt;When we want to name a category using multiple words (more than 1 word, contains spaces), jekyll will defaulty generate a permalink with the form http://domain.com/category/year/month/title and result in urls with dashes. It is the case and not bugs. We cannot easily change the permalink settings for the way Jekyll generates urls for posts in the config form but this can be done with a plugin.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;But, Github Pages just forbid any plugins&lt;/strong&gt;. Thus, it will work on your own server other than blogs on Github Pages. Therefore, I suggest no spaces in category names.  &lt;/p&gt;

&lt;h2 id=&quot;multi-categories&quot;&gt;Multi categories&lt;/h2&gt;

&lt;p&gt;The second question is we sometimes want to category one post into multiple categories, like tags. Here we need to be careful with the frontmatters. Jekyll requires that Markdown files have front-matter defined at the top of every file. And for categories, it provides two formats of frontmatters. In the Jekyll’s &lt;a href=&quot;http://jekyllrb.com/docs/frontmatter/#predefined-global-variables&quot;&gt;documentations&lt;/a&gt;, both &lt;em&gt;category&lt;/em&gt; and &lt;em&gt;categories&lt;/em&gt; are available.&lt;/p&gt;

&lt;p&gt;Is there any differences? Sure. When we just need only one category, we can use both &lt;/p&gt;

&lt;p&gt;&lt;code&gt;
category: This is one category
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;and &lt;/p&gt;

&lt;p&gt;&lt;code&gt;
categories: This is one category
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;But, you’ve may got that when comes to multiple categories, we can &lt;strong&gt;only&lt;/strong&gt; use &lt;em&gt;categories&lt;/em&gt; and carefully using two formats below:
&lt;code&gt;
categories
  - This is one category
  - This is another category
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;or the square brackets way:
&lt;code&gt;
categories: [&#39;The is a category&#39;, &#39;This is another category&#39;]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;It makes sense.&lt;/p&gt;

&lt;p&gt;So, the further question is, are &lt;em&gt;category&lt;/em&gt; and &lt;em&gt;categories&lt;/em&gt; really same when only one category? Actually, they don’t have the same effect on post object. When declaring &lt;em&gt;category&lt;/em&gt;, post.category (string) and post.categories (array) are set. When declaring &lt;strong&gt;categories&lt;/strong&gt;, only post.categories is set. Be careful!&lt;/p&gt;

&lt;h2 id=&quot;archive-posts-by-a-specific-category&quot;&gt;Archive posts by a specific category&lt;/h2&gt;

&lt;p&gt;But problems still show up when we want to archive the posts by a specific category. We may first try something like this:&lt;/p&gt;

&lt;p&gt;&lt;code&gt; 
{% for post in site.categories.&#39;This is one category&#39; %}  
...  
{% endfor %}     
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;or this:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
{% for post in site.posts | where: &#39;category&#39;,&#39;This is one category&#39; %}    
...    
{% endfor %}       
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If you tried, you failed. It is because you cannot put a filter on a loop. You have to capture first, then loop:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
{% capture myposts %} { { site.posts where: &#39;category&#39;,&#39;This is one category&#39; } }       
{% endcapture %}         
{% for post in myposts %}     
...        
{% endfor %}       
&lt;/code&gt;    &lt;/p&gt;

</description>
        
        <pubDate>Sun, 12 Apr 2015 00:00:00 +0800</pubDate>
        <link>http://yanran.li/misc/2015/04/12/github-pages-categories-with-jekyll.html</link>
        <guid isPermaLink="true">http://yanran.li/misc/2015/04/12/github-pages-categories-with-jekyll.html</guid>
      </item>
    
      <item>
        <title>Speed of Mini-Batch SGD</title>
                
        
          <description>&lt;p&gt;This post comes from a friend’s question, that he says sometimes mini-batch SGD converges more slowly than single SGD. &lt;/p&gt;

&lt;p&gt;Let’s begin with what these two kinds of method are and where they differ. Here notice that mini-batch methods come from batch methods.&lt;/p&gt;

&lt;h2 id=&quot;batch-gradient-descent&quot;&gt;Batch gradient descent&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/sgd_batch.png&quot; alt=&quot;figures from L´eon Bottou&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Batch gradient descent&lt;/strong&gt; computes the gradient using the whole dataset, while Stochastic gradient descent (SGD) computes the gradient using a single sample. This is great for convex, or relatively smooth error manifolds. In this case, we move &lt;em&gt;directly&lt;/em&gt; towards an optimum solution, either local or global. &lt;/p&gt;

&lt;h3 id=&quot;pros&quot;&gt;pros&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Great for convex, or relatively smooth error manifolds because it &lt;em&gt;directly&lt;/em&gt; towards to the optimum solution.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;cons&quot;&gt;cons&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Using the whole dataset means that it is updating the parameters using all the data. Each iteration of the batch gradient descent involves a computation of the average of the gradients of the loss function over the entire training data set. So the computation cost matters.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;stochastic-gradient-descent&quot;&gt;Stochastic gradient descent&lt;/h2&gt;

&lt;p&gt;While Batch gradient descent computes the gradient using the whole dataset, &lt;strong&gt;Stochastic gradient descent (SGD)&lt;/strong&gt; computes the gradient using a single sample. &lt;/p&gt;

&lt;h3 id=&quot;pros-1&quot;&gt;pros&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Obviously SGD’s computationally a whole lot faster. &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Single SGD works well &lt;strong&gt;better than&lt;/strong&gt; batch gradient descent &lt;em&gt;when the error manifolds that have lots of local maxima/minima&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;cons-1&quot;&gt;cons&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Sometimes, with the computational advantage, it should perform many more iterations of SGD, making many more steps than conventional batch gradient descent. &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;mini-batch-sgd&quot;&gt;mini-batch SGD&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/sgd_minibatch.png&quot; alt=&quot;figures from L´eon Bottou&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There comes the compromise of this two kinds of methods. When the batch size is 1, it is called stochastic gradient descent (GD).
When you set the batch size to 10 or to some extend larger, this method is called &lt;strong&gt;mini-batch SGD&lt;/strong&gt;. Mini-batch performs better than true stochastic gradient descent because when the gradient computed at each step uses more training examples, mini-batches tend to average a little of the noise out that single samples inherently bring. Thus, the amount of noise is reduced when using mini-batches. Therefore, we usually see smoother convergence out of local minima into a more optimal region. &lt;/p&gt;

&lt;p&gt;Thus, the batch size matters for the balance. We primally want the size to be small enough to avoid some of the poor local minima, and large enough that it doesn’t avoid the global minima or better-performing local minima. Also, a pratical consideratio raises from tractability that each sample or batch of samples must be loaded in a RAM-friendly size.&lt;/p&gt;

&lt;p&gt;So let’s be more clear:&lt;/p&gt;

&lt;h2 id=&quot;why-should-we-use-mini-batch&quot;&gt;Why should we use mini-batch?&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;It is small enough to let us implement vectorization in RAM.&lt;/li&gt;
  &lt;li&gt;Vectorization brings efficiency.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;disadvantage-of-mini-batch-sgd&quot;&gt;Disadvantage of mini-batch SGD&lt;/h2&gt;
&lt;p&gt;is the difficulty in balancing the batch size &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;. &lt;/p&gt;

&lt;p&gt;However, in the paper &lt;a href=&quot;http://link.springer.com/article/10.1007%2Fs10107-012-0572-5&quot;&gt;&lt;em&gt;Sample size selection in optimization methods for machine learning&lt;/em&gt;&lt;/a&gt;, the author points out that though large mini-batches are preferable to reduce the
communication cost, they may slow down convergence rate in practice. And Mu Li in this &lt;a href=&quot;http://www.cs.cmu.edu/~muli/file/minibatch_sgd.pdf&quot;&gt;&lt;em&gt;papar&lt;/em&gt;&lt;/a&gt; is dealing with this problem.&lt;/p&gt;

&lt;h2 id=&quot;ref&quot;&gt;Ref&lt;/h2&gt;

&lt;p&gt;[1]Bottou, Léon. &lt;em&gt;Large-scale machine learning with stochastic gradient descent.&lt;/em&gt; Proceedings of COMPSTAT’2010. Physica-Verlag HD, 2010. 177-186.&lt;/p&gt;

&lt;p&gt;[2]Bottou, Léon. &lt;em&gt;Online learning and stochastic approximations.&lt;/em&gt; On-line learning in neural networks 17.9 (1998): 142.&lt;/p&gt;

&lt;p&gt;[3]Li, Mu, et al. &lt;em&gt;Efficient mini-batch training for stochastic optimization.&lt;/em&gt; Proceedings of the 20th ACM SIGKDD international conference on Knowledge discovery and data mining. ACM, 2014.&lt;/p&gt;

</description>
        
        <pubDate>Sat, 11 Apr 2015 00:00:00 +0800</pubDate>
        <link>http://yanran.li/peppypapers/2015/04/11/speed-of-mini-batch-sgd.html</link>
        <guid isPermaLink="true">http://yanran.li/peppypapers/2015/04/11/speed-of-mini-batch-sgd.html</guid>
      </item>
    
      <item>
        <title>2014年度总结</title>
                
        
          <description>&lt;p&gt;例行总结，主要回顾下半年。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;技术&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;这半年工作中最大的体会就是维护自己常用的脚本、模板库、工作流程是多么值得的事情啊！直观地可参阅《geeks and repetitive tasks》那张图。&lt;/li&gt;
  &lt;li&gt;做爬虫的时候被 beautifulsoup4 的一些奇怪行为坑的啊，暂时用 lxml 代替（scrapy）。&lt;/li&gt;
  &lt;li&gt;被说 Python 写的很 Java，我觉得好像用起 pyquery 会好很多呢！&lt;/li&gt;
  &lt;li&gt;关于爬虫这件事，发现了一些“爬虫的艺术”的文章(http://blog.urx.com/urx-blog/2014/9/4/the-science-of-crawl-part-1-deduplication-of-web-content)蛮有趣的。比如 bloom filter 众所周知的去重错判，我暂时考虑用 dict 方式做精确去重，当然了缺陷就是内存膨胀。&lt;/li&gt;
  &lt;li&gt;在老板的莫名信任下，搭建了实验室的分布式环境。坑没有想象中多，稍微折腾了一下 native library 的问题。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;学术&lt;/h2&gt;

&lt;p&gt;年底三个月来到新的实验室，老板最初是希望我能多 support 师兄师姐。于是自己变得很 multi-task，经常周一周二优化师兄的代码，周三周四来帮学姐做些 experiment。确实充实，而且大大提高了自己的动手能力。在这种 task-driven 下，自己的效率提高了不少，也不能说因为占用了自己的思考时间而全无收获呢。&lt;/p&gt;

&lt;p&gt;年底整理 Evernote/bookmark/待读论文 Tutorial 有感：1、sequential 的回顾学习，温故知新是一定的；2、完全掌握了的东西，把它们 pop out 自己的待读列表里，成就感棒棒的；3、除了硬知识的收获，更多地可以关注自己软思维的成长。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;被 AAAI 拒了一次，虽然老板说很大原因是赶上的 reviewer 都不是做我这个方向的。但我觉得还是自己的 paper 有很多可以被人 argue 的部分吧，不够完善，不然，总是可以瑕不掩瑜的。&lt;/li&gt;
  &lt;li&gt;本来对于现在在做的事情不是很着急了，因为刚来的时候自己是实验室里进度最慢的，完全连 model 都没定，想法也不成熟。结果两个月下来开组会，老板忽然说，觉得我是最有希望 2月份 发 ACL 的。我 faint 啊……不过我还是会努力的！&lt;/li&gt;
  &lt;li&gt;现在对于学术这件事也很迷茫了，有很多时候真的无法说服自己相信自己在做一件很有价值的事情（但是手下这篇 paper 我确实觉得很 promising，当然，只是 idea promising，能不能做出来就……），而且开会的时候也总会听到老板说，这个会审稿什么风格，那个会又如何如何，感觉讨巧的东西太多。但大概这些想法只是因为我还太年轻太任性吧……&lt;/li&gt;
  &lt;li&gt;写了一本科普性的书的 Chapter，特别特别惭愧，包括之前的一本书，辜负了很多人的期待和信任吧，自己一直拖稿。这次终于狠下心好好鞭笞了自己一把，最后的自我满意度能达到 80%。不过最近回忆起这本书的内容，我还是觉得自己眼界很小，写知识，就只能写出知识，却写不出一些宏大的 Vision，全局观。我觉得一是受限于自己本身的眼界，二是受限于日益退化的表达能力……想起熊辉大大微博说的话，&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;@熊辉Rutgers
最近思考人或者企业的竞争，都是逐渐更复杂，更高级。有低到高： 1）拼勤奋； 2）拼智商 + 勤奋；3）拼 情商 + 智商 + 勤奋； 4） 拼 VISION （对未来趋势的把握） + 情商 + 智商 + 勤奋。最高等的一定有VISION&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-2&quot;&gt;心智&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;独自生活以后，确实感觉自由了很多。更深刻理解了一句话，自律等于自由。但是同时反过来想，这种自由的感觉并不是平白无故产生的。我的自由来自于我不怕失去的东西很少，和我想得到的东西都已经得到并且能轻易获得。任何选择都有得失，我们的今天，不仅是过去所有选择的总和，也是所有没得选择的总和，the way we miss our life is life。&lt;/li&gt;
  &lt;li&gt;投资自己，不再成为 job task-driven 的奴隶。持续学习，每天自己 1-2 小时时间自由学习。坚持运动，关注健康，尤其是自己的心情:P&lt;/li&gt;
  &lt;li&gt;从现在老板的身上看到了并且想学习的重要品质是与人争论的技巧。现在的我越来越喜欢能和我争论，最好能说服我的人。偏听则暗，至少这样我可以知道都有哪些相反的意见。再说回更简单的，就是要保持谦卑和好奇心。&lt;/li&gt;
  &lt;li&gt;坚持了一些不美好生活里的英雄梦想，并且要继续坚持。&lt;/li&gt;
  &lt;li&gt;自己的戾气和悲观少了很多，不安感和无力感逐渐消散。感觉自己越来越能这个世界和平相处，但庆幸自己还没有满足于他的表面的和平。我学会了发现越来越多的小确幸并且让它们变成了沉甸甸的砝码压在枕边和心头，但也同时拥有了目标实现时的巨大的成就感。我学会了享乐，也还没有忘记深刻的思考。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;读书&lt;/h2&gt;
&lt;p&gt;终于开始觉得，读书是一件很私人的事情。以后不再多做读书总结了。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;交易&lt;/h2&gt;
&lt;p&gt;下半年交易中分了两个阶段，一个是因为从八月开始我就不断觉得美股要见顶了（这个预测现在反思是有点早了）我便逐渐减仓了美股，第二个就是自己时间上不再允许时差看盘，转而进入A股。
后来十月中旬的时候基本手头美股仓位基本只有 APPL 和 BITA 了。APPL 我从 83 一直拿到 118，我觉得这是2014年下半年自己做的最好的一只。A股这边自己就只是小追了一下军工和环保。对A股我还是比较谨慎，还是慢慢摸索。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;每个人适合的交易方法不一样。不要总观察别人的操作，也不要自己频繁操作，而是去想清楚什么是重要的。&lt;/li&gt;
  &lt;li&gt;我现在觉得风控是第一位的，A股之前的资金效应带动的版块，很多人都被套了，这种毫无逻辑支撑的大涨，看不清楚，宁愿不追。&lt;/li&gt;
  &lt;li&gt;风控，资金。&lt;/li&gt;
  &lt;li&gt;技术流中，找突破还是最稳健的办法。$MS 的图形值得收藏。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;============以下是上半年的交易心得总结=============&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;个股和指数是不同的，个股也分很多种，不能一概而论。有些个股适合长情，看好他们，有些个股适合一夜情，不可以多拿。&lt;/li&gt;
  &lt;li&gt;能源是最棒我赚钱的股票，我从3月乌克兰事件一直拿到现在。长得稳，大盘好的时候它们涨的慢一些，大盘不好的时候涨幅更大。&lt;/li&gt;
  &lt;li&gt;做熟悉的股票。这半年我交易次数最多的股票应该是 TNA，它的每个历史点关键位我都很熟悉，可以很快认清走势，做出判断，做了很长一段时间的 DT。每周都有一两天的时间可以让我赚 1-2 块。&lt;/li&gt;
  &lt;li&gt;现在在测试一个自己的交易系统，这个系统不用主观判断，只用指标来决定买卖。买入在最容易止损的位置。年底再来总结。&lt;/li&gt;
  &lt;li&gt;我验证了一下自己对于每次判断的正确率，大概在65%，还比较低，但是这不妨碍我交易。如果自己错了，就立刻止损，重新判断，所以我更看重买入的位置，要很容易止损。如果止损错了，又很容易买回。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-5&quot;&gt;运动&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;坚持跑步而已。最喜欢的自虐方式了。&lt;/li&gt;
  &lt;li&gt;后来找到了朋友陪我打壁球，虽然打得不咋样，不过很适合我这种暴力女啊。&lt;/li&gt;
  &lt;li&gt;2015准备养成一些无器械运动的习惯。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-6&quot;&gt;习惯&lt;/h2&gt;

&lt;p&gt;养成了一些习惯：
1. 每周五整理桌面
2. 每天两次查看 to-do
3. Wunderlist App 作为包括买菜清单、回家见人备忘等的 checklist，非常好用！
4. 周末洗床单被套、半周洗枕套&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;人&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;下半年最大的悲哀是被“骗”了钱，人生第一次吧。太过于信任对方。不过，金钱上的损失并不可怕，我也很快调整了心态，虽然我没吸取到啥教训的样子，但是并不会因此而不再相信人。希望自己永远有一个好心态面对不顺心，坚持自己的信心、梦想和好品质。&lt;/li&gt;
  &lt;li&gt;生活禁不起推敲，不精确，不如意，不停止，力所难及。我带着悲哀，穿过荒唐，遇见时间，和你。&lt;/li&gt;
  &lt;li&gt;“无论你怎么与他人控制距离，你依然会失去控制，因为这个世界上总有人能让你乖乖交心和伤心。from 韩寒《告白与告别》”&lt;/li&gt;
  &lt;li&gt;前几天摘了尼采的话：“总之，问题全在于生命力： 你健康，你就热爱生命，向往人生的欢乐；你羸弱，你就念念不忘死亡，就悲观厌世。一个要在人世间有所建树的人最忌悲观主义：”看破红尘–这是巨大的疲劳和一切创造者的末日。”也就是那句，Pain is inevitable. Suffering is optional.&lt;/li&gt;
  &lt;li&gt;一段看似荒唐却真实的感情，便看淡了很多事情。如果人可以有无限的体验，全知全能，那么人与人之间的真正理解是绝对可达的。如果上帝真是那全知全能的神，他爱世人，我便信。不过经此一遭，我越发豁达和潇洒了。荒唐有时，开心到老。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-8&quot;&gt;2015目标&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;提高书面表达能力（写博客）&lt;/li&gt;
  &lt;li&gt;无器械健身&lt;/li&gt;
  &lt;li&gt;更有型一点&lt;/li&gt;
  &lt;li&gt;学会自拍！&lt;/li&gt;
  &lt;li&gt;每个月总结一次自己的技术收获，项目总结，而不要半年一次&lt;/li&gt;
  &lt;li&gt;买一双 Christian Louboutin 红底鞋！&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后还是谢谢这一年关心我、鼓励我、给过我机会、在我困惑时给我当头棒喝和温柔怀抱的路人和朋友们，因为你们和好书好吃的，才让我觉得生活越来越美好！&lt;/p&gt;

</description>
        
        <pubDate>Wed, 31 Dec 2014 00:00:00 +0800</pubDate>
        <link>http://yanran.li/misc/2014/12/31/2014%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93.html</link>
        <guid isPermaLink="true">http://yanran.li/misc/2014/12/31/2014%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93.html</guid>
      </item>
    
      <item>
        <title>ADMM 框架小结</title>
                
        
          <description>&lt;p&gt;ADMM 是这两年很火的一个算法框架。&lt;/p&gt;

&lt;p&gt;其主要的提出想法是为了“分布式”的解决一类问题，即：
&lt;script type=&quot;math/tex&quot;&gt;min f(x) + g(y)
s.t. Ax + By = c&lt;/script&gt;
是等式约束（不可以是不等式）的最小化加和问题；且此时 f(x) 和 g(y) 是两类性质非常不同的函数，比如 LASSO 中的 1-norm 惩罚和前面的代价函数。&lt;/p&gt;

&lt;p&gt;对于这个问题的 augmentated Lagrangian:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;L_{\rho}(x,z,y)=f(x)+g(z)+y^T(Ax+Bz-c)+(\rho/2)\|Ax+Bz-c\|_2^2&lt;/script&gt;

&lt;p&gt;和对应的 update rule:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x^{k+1}=\arg\min_x L_{\rho}(x,z^k,y^k)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;z^{k+1}=\arg\min_z L_{\rho}(x^{k+1},z,y^k)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;y^{k+1}=y^k+\rho(Ax^{k+1}+Bz^{k+1}-c)&lt;/script&gt;

&lt;p&gt;可以看出，上图中的第一个式子和第二个式子是乘子法的一个特殊化；且第一个式子对应的是乘子法中的”x-minimization step”，第二个式子是所谓的“dual update”。&lt;/p&gt;

&lt;p&gt;不同的是，乘子法是同时计算并最小化x,z：
&lt;script type=&quot;math/tex&quot;&gt;(x^{k+1},z^{k+1})=\arg\min_{x,z} L_{\rho}(x,z,y^k)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;而ADMM中，x,z 是“alternated”计算的，它 decouples x-min step from y-min step。&lt;/p&gt;

&lt;p&gt;这里可以看到，augmentated Lagrangian 虽然弱化了乘子法的强假设性，但 x-min step 引入了二次项而导致无法把 x 分开进行求解。所以 ADMM 也是就是期望结合乘子法的弱条件的收敛性以及对偶上升法的可分解求解性。&lt;/p&gt;

&lt;p&gt;其实 ADMM 也是一个需要 trick 的框架：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;因为它的缺点是需要非常多步的迭代才能得到相对精确的解，这就好像是一阶算法。  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;另外，对 $\rho$ 的选择也很重要，非常影响收敛性；$\rho$ 太大，对于 min (f1+f2) 就不够重视；反之，则对于 feasibility 又不够重视。Boyd et al. (2010) 倒是给了实践中改变 $\rho$ 的策略，可是也没有证明它的收敛性。   &lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Boyd 在其&lt;a href=&quot;http://web.stanford.edu/~boyd/papers/admm/&quot;&gt;网站&lt;/a&gt;上给出了一些例子。总结这里的几个例子，构造 ADMM 的形式，主要思想就是往直前的受约束的凸优化问题靠拢。
（1）对于只有传统损失函数没有正则项的（比如LAD, Huber Fitting），构造出一个 z。
（2）对于有约束的，比如 l1-norm 的约束，则把约束变成 g(x)，原始损失函数为 f(x)。若 f(x) 本身没有（比如Basic Pursuit），就构造成带有定义域约束的 f(x)（某种投影）；如果有，则就是比较一般化的损失+正则问题，这时候就基本是一个&lt;script type=&quot;math/tex&quot;&gt;f(x)+\lambda\|z\|_1&lt;/script&gt;的形式。是非常自然的 ADMM。&lt;/p&gt;

&lt;p&gt;所以，像广义线性模型和广义可加模型+正则等等都非常适合 ADMM。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Ref:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;[1] S. Boyd, N. Parikh, E. Chu, B. Peleato, and J. Eckstein Distributed Optimization and Statistical Learning via the Alternating Direction Method of Multipliers, 2010.&lt;/p&gt;

&lt;p&gt;[2] S. Boyd. Alternating Direction Method of Multipliers (Slides)&lt;/p&gt;

</description>
        
        <pubDate>Mon, 07 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://yanran.li/machinelearning/2014/07/07/ADMM-%E6%A1%86%E6%9E%B6%E5%B0%8F%E7%BB%93.html</link>
        <guid isPermaLink="true">http://yanran.li/machinelearning/2014/07/07/ADMM-%E6%A1%86%E6%9E%B6%E5%B0%8F%E7%BB%93.html</guid>
      </item>
    
      <item>
        <title>Relation Extraction with Matrix Factorization</title>
                
        
          <description>&lt;p&gt;This post is about the NAACL’13 Accepted Paper, &lt;strong&gt;Relation Extraction with Matrix Factorization and Universal Schemas&lt;/strong&gt;. The talk is available on &lt;a href=&quot;http://techtalks.tv/talks/relation-extraction-with-matrix-factorization-and-universal-schemas/58435/&quot;&gt;techtalks&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;And then present some basic knowledge of &lt;strong&gt;Matrix Factorization&lt;/strong&gt;. &lt;/p&gt;

&lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;/h2&gt;

&lt;p&gt;The paper studies techniques for inferring a model of entities and relations capable of performing basic types of semantic inference (e.g., predicting if a specific relation holds for a given pair of entities). The models exploit different types of embeddings of entities and relations.  &lt;/p&gt;

&lt;p&gt;This problem is usually tackled either via distant weak supervision from a knowledge base (providing structure and relational schemas) or in a totally unsupervised fashion (without any pre-defined schemas). The present approach aims at combining both trends with the introduction of universal schemas that can blend pre-defined ones from knowledge bases and uncertain ones extracted from free text.  This paper is very ambitious and interesting. &lt;/p&gt;

&lt;h2 id=&quot;related-work&quot;&gt;Related Work&lt;/h2&gt;

&lt;h3 id=&quot;relation-extraction&quot;&gt;relation extraction&lt;/h3&gt;

&lt;p&gt;There has been a lot of previous research on learning entailment (aka inference) rules (e.g., Chkolvsky and Pantel 2004; Berant et al, ACL 2011; Nakashole et al, ACL 2012). 
Also, there has been some of the very related work on embedding relations, e.g., Bordes et al (AAAI 2011), or, very closely related, Jenatton et al (NIPS 2012).&lt;/p&gt;

&lt;h3 id=&quot;matrix-factorization&quot;&gt;Matrix Factorization&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Matrix factorization&lt;/strong&gt; as a technique of &lt;em&gt;Collaborative filtering&lt;/em&gt; has been the
preferred choice for recommendation systems ever since Netflix million competition was held a few years back. Further, with the advent of news personalization, advanced search and user analytics, the concept has gained
prominence.&lt;/p&gt;

&lt;p&gt;In this paper, columns correspond to relations, and rows correspond to entity tuples. By contrast, in (Murphy et al., 2012) columns are words, and rows
are contextual features such as “words in a local window.” Consequently, this paper’s objective is to complete the matrix, whereas their objective is to learn better latent embeddings of words (which by themselves again cannot capture any sense of asymmetry).&lt;/p&gt;

&lt;h2 id=&quot;save-storage&quot;&gt;Save Storage&lt;/h2&gt;

&lt;p&gt;Although the paper doesn’t explicit point out how common is it that a tuple shares many relations, it remains concern. The experiments seem to show that mixing data sources is beneficial. &lt;/p&gt;

&lt;h2 id=&quot;trends&quot;&gt;Trends&lt;/h2&gt;

&lt;p&gt;The researchers are ambitious to bridge knowledges bases and text for information extraction, and this paper seems to go along this trend.
However, the paper’s scheme is limited before complex named entity disambiguation is solved, since it relies on the fact that entities constituting tuples from the Freebase and tuples extracted from the text have been exactly matched beforehand.&lt;/p&gt;

&lt;h2 id=&quot;generalized-matrix-factorization&quot;&gt;Generalized Matrix Factorization&lt;/h2&gt;

&lt;p&gt;It has been a general machine learning problem formulated as:&lt;/p&gt;

&lt;h3 id=&quot;training-data&quot;&gt;Training data&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;V&lt;/strong&gt;: m x n input matrix (e.g., rating matrix)&lt;/li&gt;
  &lt;li&gt;Z: training set of indexes in &lt;strong&gt;V&lt;/strong&gt; (e.g., subset of known ratings)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;parameter-space&quot;&gt;Parameter space&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;W&lt;/strong&gt;: row factors (e.g., m x r latent customer factors)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;H&lt;/strong&gt;: column factors (e.g., r x n latent movie factors)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;model&quot;&gt;Model&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt; L_{ij}(W_{i*},H_{*j}) &lt;/script&gt;: loss at element (&lt;em&gt;i&lt;/em&gt;,&lt;em&gt;j&lt;/em&gt;)&lt;/li&gt;
  &lt;li&gt;Includes prediction error, regularization, auxiliary information, . . .&lt;/li&gt;
  &lt;li&gt;Constraints (e.g., non-negativity)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;find-best-model&quot;&gt;Find best model&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; \arg\min_{W,H}\sum_{(i,j)\in Z}L_{i,j}(W_{i*},H_{*j}) &lt;/script&gt;

&lt;h2 id=&quot;stochastic-gradient-descent-for-matrix-factorization&quot;&gt;Stochastic Gradient Descent for Matrix Factorization&lt;/h2&gt;

&lt;p&gt;Among the various algorithmic techniques available, the following are more
popular: &lt;strong&gt;Alternating Least Squares (ALS)&lt;/strong&gt;， &lt;strong&gt;Non-Negative Matrix Factorization&lt;/strong&gt; and &lt;strong&gt;Stochastic Gradient Descent (SGD)&lt;/strong&gt;. Here I only presents SGD for MF.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SDG&lt;/strong&gt; is a well know technique which tends to compute direction of steepest descent and then takes a step in that direction. Among the variants include:&lt;/p&gt;

&lt;p&gt;(a)Partitioned SGD: distribute without using stratification and run independently and in parallel on partitions (b)Pipelined SGD: based on ‘delayed update’ scheme (c)Decentralized SGD: computation in decentralized and distributed fashion&lt;/p&gt;

&lt;p&gt;The main solution is as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Set &lt;script type=&quot;math/tex&quot;&gt; \theta = (W,H) &lt;/script&gt; and use&lt;/p&gt;

    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt; L(\theta)=\sum_{(i,j)\in Z}L_{ij}(W_{i*},H_{*j}) &lt;/script&gt;,  &lt;br /&gt;
  &lt;script type=&quot;math/tex&quot;&gt; {L}&#39;(\theta)=\sum_{(i,j)\in Z}{L}&#39;_{ij}(W_{i*},H_{*j}) &lt;/script&gt;,  &lt;br /&gt;
  &lt;script type=&quot;math/tex&quot;&gt; {\hat{L}}&#39;(\theta,z)=N{L}&#39;_{i_{z}j_{z}}(W_{i_{z}*},H_{*j_{z}}) &lt;/script&gt;, where &lt;script type=&quot;math/tex&quot;&gt;N=\vert Z\vert&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SGD epoch&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Pick a random entry &lt;script type=&quot;math/tex&quot;&gt; z \in Z &lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;Compute approximate gradient &lt;script type=&quot;math/tex&quot;&gt; {\hat{L}}&#39;(\theta,z) &lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;Update parameters &lt;script type=&quot;math/tex&quot;&gt; \theta_{n+1}=\theta_{n}-\epsilon_{n}{\hat{L}}&#39;(\theta,z) &lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;Repeat &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; times&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;svm-vs-fm&quot;&gt;SVM V.S. FM&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;FM&lt;/strong&gt; is short for &lt;a href=&quot;http://www.libfm.org/&quot;&gt;&lt;strong&gt;Factorization Machine&lt;/strong&gt;&lt;/a&gt;. Indeed, it can be interpreted as &lt;strong&gt;Factorization&lt;/strong&gt; Methods and Support Vector &lt;strong&gt;Machine&lt;/strong&gt;. It is firstly published by Steffen Rendle. &lt;/p&gt;

&lt;p&gt;Factorization machines (FM) are a generic approach that allows to mimic most factorization models by feature engineering. This way, factorization machines combine the generality of feature engineering with the superiority of factorization models in estimating interactions between categorical variables of large domain. libFM is a software implementation for factorization machines that features stochastic gradient descent (SGD) and alternating least squares (ALS) optimization as well as Bayesian inference using Markov Chain Monte Carlo (MCMC).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/Kc7q9Pl.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;in SVM mode, &lt;script type=&quot;math/tex&quot;&gt; y(x)=w\cdot x+b=w_{u}+w_{i}+...+b=\sum w_{i}x_{i}+b &lt;/script&gt;, but original SVM fails with 2 main problems using here: &lt;em&gt;Real Value V.S. Classification&lt;/em&gt;, and &lt;em&gt;Sparsity&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;in Factorization Machine mode, it is solved as: &lt;script type=&quot;math/tex&quot;&gt; y(x)=\sum w_{i}x_{i}+\sum\sum(v_{i}\cdot v_{j})x_{i}x_{j} +b &lt;/script&gt;. The second part in the formula is &lt;strong&gt;Factorization&lt;/strong&gt;, where the transformation from original SVM to FM lies.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/bgOUxWh.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;http://i.imgur.com/eHhxEsb.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;fm-vs-mf&quot;&gt;FM V.S. MF&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;FM: &lt;script type=&quot;math/tex&quot;&gt; y(x)=\sum w_{i}x_{i}+\sum\sum(v_{i}\cdot v_{j})x_{i}x_{j} +b &lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;MF: &lt;script type=&quot;math/tex&quot;&gt; y(x)=w_{u}+w_{i}+v_{u}\cdot v_{i} + b &lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        
        <pubDate>Mon, 11 Nov 2013 00:00:00 +0800</pubDate>
        <link>http://yanran.li/naturallanguageprocessing/2013/11/11/Relation-Extraction-with-Matrix-Factorization.html</link>
        <guid isPermaLink="true">http://yanran.li/naturallanguageprocessing/2013/11/11/Relation-Extraction-with-Matrix-Factorization.html</guid>
      </item>
    
      <item>
        <title>Incorpating Domain Knowledge into LDA</title>
                
        
          <description>&lt;p&gt;Recent years, there has been emerging research on knowledge-based models and methods. Researchers have tried in various ways to express/embed/structure the knowledge and then incorporating them into some existing models, among which is LDA (Latent Dirichlet Allocation). &lt;/p&gt;

&lt;p&gt;For further detailed about LDA, please investigate through [Blei el al., 2003].  The basic idea and foundation of LDA is handling &lt;strong&gt;word co-occurrence&lt;/strong&gt; pattern to discover the latent semantic meaning. The simple model has limited resolution to deeper latent sementics and thus the variations of LDA are bursting. One focus to expand LDA is how to incorporating more &lt;strong&gt;prior knowledge&lt;/strong&gt; into it.&lt;/p&gt;

&lt;h2 id=&quot;types-of-prior-knowledge&quot;&gt;Types of Prior Knowledge&lt;/h2&gt;

&lt;p&gt;Basically, all types of knowledge incorporation is to change the prior distribution of Dirichlet setting in LDA. &lt;/p&gt;

&lt;p&gt;a.	在传统 LDA 里，有两组先验，一种是文档~主题的先验，来自于一个对称的&lt;script type=&quot;math/tex&quot;&gt; \mathcal Dir(\alpha) &lt;/script&gt;；一种是主题~词汇的先验，来自于一个对称的&lt;script type=&quot;math/tex&quot;&gt; \mathcal Dir(\beta) &lt;/script&gt; ——都是 symmetric Dirichlet Distribution。所以按理，可以把这两种先验分别改成不对称的——这样就加入了更多的 knowledge 信息。&lt;/p&gt;

&lt;p&gt;b.	在 Rethinking LDA 里一文&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;中，结合两种先验与两种不同的先验设定方法，可以得到以下四种组合：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AA：文档~主题分布和主题~词汇分布都采用非对称；&lt;/li&gt;
  &lt;li&gt;AS：文档~主题分布采用非对称的先验，而主题~词汇分布采用对称的先验；&lt;/li&gt;
  &lt;li&gt;SA：文档~主题分布采用对称的先验，而主题~词汇采用非对称；&lt;/li&gt;
  &lt;li&gt;SS：文档~主题分布和主题~词汇分布都采用对称的先验。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;他们的实验发现其中 AS 的方法可以更高地提高 LDA 对于文本建模的能力。&lt;/p&gt;

&lt;p&gt;c.  典型的打破“对称”文档~主题分布先验（AS）的几个model，有很好理解的 Twitter-LDA，也有 Behavior-LDA。同时，supervised-LDA 也可以看做一个非结构化的打破先验的方式，变形后有 SeededLDA（在两个层次的先验都通过设计加入了不对称信息）。&lt;/p&gt;

&lt;p&gt;d.	除了通过&lt;strong&gt;直接&lt;/strong&gt;地改变概率分布来加入先验的方法，这几年来开始有越来越多的研究者想将结构化的先验知识加入 LDA 。这种结构化的先验，不再是简单的 prior distribution，更可以倾向于称为“knowledge”。这样的研究之所以盛行，一方面是长期以来的结构化知识库已有很多（且因为还要继续建立知识图谱等，结构化仍将是未来的趋势），另一方面形式语言（逻辑语言）的表示的研究一直都没有停止。这种结构化的引入 knowledge 的方法，本质也是通过打破先验设定的 symmetric Dirichlet Distribution。下文将重点总结这方面的工作。&lt;/p&gt;

&lt;h2 id=&quot;domain-dependent-model&quot;&gt;Domain-dependent Model：&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CIKM’13 里，Zhiyuan Chen（也在 Bing Liu那里）的一篇 Discovering Coherent Topics&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; 里将 incorporating knowledge 的研究分成了 domain-dependent 的和 domain-independent：前者是 expert 知道（普通人不一定熟悉，需要 expert 来参与编辑）的知识而且有知识领域限制，后者是各领域通用的一些知识。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同样是上述文章，提到了&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;,&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;,&lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;,&lt;sup id=&quot;fnref:6&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;,&lt;sup id=&quot;fnref:7&quot;&gt;&lt;a href=&quot;#fn:7&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt; 的论文都是 domain-dependent knowledge-based 的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其中，Dirichlet Forest&lt;sup id=&quot;fnref:2:1&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; 和 Jerry Zhu 的 First-Order Logic&lt;sup id=&quot;fnref:4:1&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt; 的形式化加入 domain-knowledge 的方法还是比较有代表性。前者是将领域内一定会一起出现（两个词的出现概率都很大或者都很小）的词和一定不能一起出现的词分别表示为 Must-Link 和 Cannot-Link，然后表示成树中的结点和结点之间的连接关系。但这个 Link 关系是可传递的，所以会导致“错误”的先验知识加入（CIKM’13 中提到了这点）。         &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;domain-independent-model&quot;&gt;Domain-independent Model：&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;按照 Zhiyuan Chen 的说法，他们在 CIKM’13 里提出的 GK-LDA&lt;sup id=&quot;fnref:3:1&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; 应该是第一个 domain-independent model。所以这个部分只谈他们的那篇论文（GK-LDA 是 General Knowledge 的缩写，即 domain-independent 的 knowledge）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在这篇论文里，他们的假设是，&lt;em&gt;there is a vast amount of available in online dictionaries or other resources that can be exploited in a model to generate more coherent topic&lt;/em&gt;. 而通过 extract，就可以把这样的 lexical knowledge 提取成 a general knowledge base.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;他们采取的知识表达结构是 lexical relationships on words. 简称 &lt;strong&gt;LR-sets&lt;/strong&gt;。LR-sets 有很多种关系，比如同义词、反义词，这篇文章中重点讲的是 adjective-attribute 这种 relationship，e.g. (expensive-price).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;他们提出的 GK-LDA 依然是 一种 LDA 的变形，而且是基于他们组再之前的工作——IJCAI’13 的 Leveraging Multi-Domain Prior Knowledge&lt;sup id=&quot;fnref:8&quot;&gt;&lt;a href=&quot;#fn:8&quot; class=&quot;footnote&quot;&gt;8&lt;/a&gt;&lt;/sup&gt; 里的 MDK-LDA。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mdk-lda-b--mdk-lda--gk-lda&quot;&gt;从 MDK-LDA (b) 到 MDK-LDA 到 GK-LDA：&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;主要总结 Zhiyuan Chen 的两篇工作，之前提过的 MDK-LDA 和 GK-LDA。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MDK-LDA 是 multi-domain knowledge 的缩写，从思想上来看是一种 Transfer Learning 的想法，prior from other domain can help topic model in new domain.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;所谓的 multi-domain 可以通过 &lt;strong&gt;s-set&lt;/strong&gt; 表示，比如 “light” has 2 s-set {light, heavy, weight} 和 {light, bright, luminanee}，表示出了 light 的两个词义。那么这个工作就是去 leverage 这个 s-sets。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;他们在 IJCAI’13 的那篇里&lt;sup id=&quot;fnref:8:1&quot;&gt;&lt;a href=&quot;#fn:8&quot; class=&quot;footnote&quot;&gt;8&lt;/a&gt;&lt;/sup&gt; 主要分析了 之前的 domain-knowledge 会遇到的两个大问题，MDK-LDA 解决了其中一个 adverse effect 的问题，而 GK-LDA 两个都解决了（还有一个是错误先验知识带来的问题）。MDK-LDA 解决的主要在 LDA 问题里，如何使得一些少见的词但是确实是同一个 set 里的词的低频不会影响 topic modeling 的学习（不仅仅用 TF-IDF 消除影响），那么他们认为 &lt;em&gt;the words in an s-set share a similar semantic meaning in the model should redistribute the probability masses over words in the s-set to ensure that they have similar probability under the same topic&lt;/em&gt;. 这个思想使得他们在 MDK-LDA(basic) 之上加入了 GPU &lt;sup id=&quot;fnref:9&quot;&gt;&lt;a href=&quot;#fn:9&quot; class=&quot;footnote&quot;&gt;9&lt;/a&gt;&lt;/sup&gt;：像抽出小球再放回同颜色的球的思想一样，去改变同一个 s-set 里的 word 的dist.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 MDK-LDA 之上，解决第二个问题的就是 GK-LDA，也就是在 CIKM’13 里的那篇&lt;sup id=&quot;fnref:3:2&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。MDK-LDA 没法避免当我们的先验 s-set 是错误的（这也是其他许多 domain-dependent model 的问题，必须保证我们的先验知识都是正确的）对 performance 的影响。 GK-LDA 加入了一个 word correlation matrix 的计算 和 加入一个 threshold，减少了 wrong LR-set 的的影响。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其中加入 GPU 的思想，和 CRP 中如何改变人坐在具体某个餐桌的概率的思想是一致的（只是一个模型的不同解释）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;footnotes&quot;&gt;Footnotes&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Transfer Learning 和 Active Learning、Online Learning 等等都有关系。这部分内容还没有系统学习过，之前一篇&lt;a href=&quot;http://yanran.li/2013/07/covariate-shift-correction/&quot;&gt;文章&lt;/a&gt;也有提到这里的一个小坑。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GPU&lt;sup id=&quot;fnref:9:1&quot;&gt;&lt;a href=&quot;#fn:9&quot; class=&quot;footnote&quot;&gt;9&lt;/a&gt;&lt;/sup&gt;，是 Generalized Polya Urn 的简称。搞懂 LDA 必须先学习的模型。将这个过程generalized, 可以推向Polya Urn’s Process。Polya Urn’s Model 是比较直观的理解 Dirichlet Process 的一种解释模型。模型中抽出球再放回就是对当前的多项分布进行抽样（同时不改变该分布），又放回一个同样的球就是依当前多项分布产生新的多项分布。假设从&lt;script type=&quot;math/tex&quot;&gt; \mathcal Dir(\alpha, K) &lt;/script&gt;中抽样，那么新产生的多项分布共有 K 个，其概率质量与当前多项分布成比例。K 个新产生的多项分布的加权平均与原多项分布是同分布的。而在之前的 CIKM’13 论文&lt;sup id=&quot;fnref:3:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;中就是通过改变每次放回的“球”（LR-set 里同一个 set 的词）的“颜色”和数量来改变 prior knowledge 的。这种思想感觉还是很赞的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;Hanna Wallach, David Mimno and Andrew McCallum. Rethinking LDA: Why Priors Matter. NIPS, 2009, Vancouver, BC. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;Zhiyuan Chen, Arjun Mukherjee, Bing Liu, Meichun Hsu, Malu Castellanos, and Riddhiman Ghosh. Discovering Coherent Topics using General Knowledge. Proceedings of the ACM Conference of Information and Knowledge Management (CIKM’13). October 27 - November1, Burlingame, CA, USA. &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:3:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; &lt;a href=&quot;#fnref:3:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; &lt;a href=&quot;#fnref:3:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;Andrzejewski, D., Zhu, X. and Craven, M. 2009. Incorporating domain knowledge into topic modeling via Dirichlet Forest priors. ICML, 25–32. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:2:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;Andrzejewski, D., Zhu, X., Craven, M. and Recht, B. 2011. A framework for incorporating general domain knowledge into latent Dirichlet allocation using first-order logic. IJCAI, 1171–1177. &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:4:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot;&gt;
      &lt;p&gt;Burns, N., Bi, Y., Wang, H. and Anderson, T. 2012. Extended Twofold-LDA Model for Two Aspects in One Sentence. Advances in Computational Intelligence. Springer Berlin Heidelberg. 265–275. &lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:6&quot;&gt;
      &lt;p&gt;Jagarlamudi, J., III, H.D. and Udupa, R. 2012. Incorporating Lexical Priors into Topic Models. EACL, 204–213 &lt;a href=&quot;#fnref:6&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:7&quot;&gt;
      &lt;p&gt;Mukherjee, A. and Liu, B. 2012. Aspect Extraction through SemiSupervised Modeling. ACL, 339–348. &lt;a href=&quot;#fnref:7&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:8&quot;&gt;
      &lt;p&gt;Zhiyuan Chen, Arjun Mukherjee, Bing Liu, Meichun Hsu, Malu Castellanos, and Riddhiman Ghosh. Leveraging Multi-Domain Prior Knowledge in Topic Models. Proceedings of the 23rd International Joint Conference on Artificial Intelligence (IJCAI’13). August 3-9, 2013, Beijing, China. &lt;a href=&quot;#fnref:8&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:8:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:9&quot;&gt;
      &lt;p&gt;David Mimno, Hanna Wallach, Edmund Talley, Miriam Leenders, Andrew McCallum. Optimizing Semantic Coherence in Topic Models. EMNLP (2011). &lt;a href=&quot;#fnref:9&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:9:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        
        <pubDate>Sat, 05 Oct 2013 00:00:00 +0800</pubDate>
        <link>http://yanran.li/peppypapers/2013/10/05/incorporating-domain-knowledge-into-LDA.html</link>
        <guid isPermaLink="true">http://yanran.li/peppypapers/2013/10/05/incorporating-domain-knowledge-into-LDA.html</guid>
      </item>
    
      <item>
        <title>Loading Big Data in R</title>
                
        
          <description>&lt;p&gt;Although parallel techniques in R has been prevailing, I will only focus on Loading the complete data into RAM in R, that is to say, no Hadoop or similar. What other more I &lt;em&gt;won’t&lt;/em&gt; mention in this post is about &lt;a href=&quot;http://www.r-bloggers.com/big-data-analysis-for-free-in-r-or-how-i-learned-to-load-manipulate-and-save-data-using-the-ff-package/&quot;&gt;manipulating and saving big data in R&lt;/a&gt;, and parallel computing.&lt;/p&gt;

&lt;p&gt;Just start with different implementations:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;load &lt;strong&gt;csv&lt;/strong&gt; file and using &lt;strong&gt;ff&lt;/strong&gt; package (Rtools)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  bigdata &amp;lt;- read.csv.ffdf(file = ”bigdata.csv”, first.rows=5000, colClasses = NA)
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;em&gt;Notice&lt;/em&gt; that ff package should be in Rtools on Windows.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;using &lt;strong&gt;sqldf()&lt;/strong&gt; from &lt;strong&gt;SQLite&lt;/strong&gt; &lt;/p&gt;

    &lt;p&gt;this is a method from &lt;a href=&quot;http://stackoverflow.com/a/1820610/1849063&quot;&gt;StackOverflow&lt;/a&gt;: using sqldf() to import the data into SQLite as a staging area, and then sucking it from SQLite into R&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  library(sqldf)
  f &amp;lt;- file(&quot;bigdf.csv&quot;)
  system.time(bigdf &amp;lt;- sqldf(&quot;select * from f&quot;, dbname = tempfile(), file.format = list(header = T, row.names = F)))
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;magic &lt;strong&gt;data.table&lt;/strong&gt; and &lt;strong&gt;fread&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;it includes data.frame, but some of the syntax is different. Luckily, the &lt;a href=&quot;http://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.pdf&quot;&gt;documentation&lt;/a&gt; (and the FAQ) are excellent.&lt;/p&gt;

    &lt;p&gt;Read csv-files with the fread function instead of read.csv (read.table). It is faster in reading a file in table format and gives you feedback on progress.&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;Notice&lt;/em&gt; that fread() cannot directly read gzipped files and it comes with a big warning sign “not for production use yet”. One trick it uses is to read the first, middle, and last 5 rows to determine column types.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;optimized &lt;strong&gt;read.table()* with **colClasses&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;This option takes a vector whose length is equal to the number of columns in year table. Specifying this option instead of using the default can make ‘read.table’ run MUCH faster, often twice as fast. In order to use this option, you have to know the of each column in your data frame. - See more at &lt;a href=&quot;http://simplystatistics.tumblr.com/post/11142408176/r-workshop-reading-in-large-data-frames#sthash.IpNe4GfP.dpuf&quot;&gt;hear&lt;/a&gt;.&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  read.table(&quot;test.csv&quot;,header=TRUE,sep=&quot;,&quot;,quote=&quot;&quot;,  
                    stringsAsFactors=FALSE,comment.char=&quot;&quot;,nrows=n,                   
                    colClasses=c(&quot;integer&quot;,&quot;integer&quot;,&quot;numeric&quot;,                        
                                 &quot;character&quot;,&quot;numeric&quot;,&quot;integer&quot;))
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;load a &lt;strong&gt;portion&lt;/strong&gt; using &lt;strong&gt;nrows&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;Also you can read in only a portion of your file, to get a feel of the dataset.&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  data_first_100 &amp;lt;- read.table(&quot;file&quot;, header=T, sep=&quot;\t&quot;, stringsAsFactors=F, nrows=100)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;in summary&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/a/15058684/1849063&quot;&gt;Here&lt;/a&gt; is a great comparison summary for the method above with their system time. I just copy the summary table below:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  ##    user  system elapsed  Method
  ##   24.71    0.15   25.42  read.csv (first time)
  ##   17.85    0.07   17.98  read.csv (second time)
  ##   10.20    0.03   10.32  Optimized read.table
  ##    3.12    0.01    3.22  fread
  ##   12.49    0.09   12.69  sqldf
  ##   10.21    0.47   10.73  sqldf on SO
  ##   10.85    0.10   10.99  ffdf
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;See more in &lt;a href=&quot;http://www.theodi.org/blog/fig-data-11-tips-how-handle-big-data-r-and-1-bad-pun&quot;&gt;11 Tips on How to Handle Big Data in &lt;/a&gt;.&lt;/p&gt;

</description>
        
        <pubDate>Fri, 04 Oct 2013 00:00:00 +0800</pubDate>
        <link>http://yanran.li/r/2013/10/04/loading-big-data-in-R.html</link>
        <guid isPermaLink="true">http://yanran.li/r/2013/10/04/loading-big-data-in-R.html</guid>
      </item>
    
  </channel>
</rss>